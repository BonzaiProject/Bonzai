/**
 *        _            ____                     _ _             ____
 *  _ __ | |__  _ __  / ___|_   _  __ _ _ __ __| (_) __ _ _ __ |___ \
 * | '_ \| '_ \| '_ \| |  _| | | |/ _` | '__/ _` | |/ _` | '_ \  __) |
 * | |_) | | | | |_) | |_| | |_| | (_| | | | (_| | | (_| | | | |/ __/
 * | .__/|_| |_| .__/ \____|\__,_|\__,_|_|  \__,_|_|\__,_|_| |_|_____|
 * |_|         |_| phpGuardian CLI
 *
 *
 * PHPGUARDIAN2
 *
 * CODE NAME:      phoenix
 * ENGINE VERSION: 4.0
 * MODULE VERSION: 1.0
 *
 * URL:            http://www.phpguardian.org
 * E-MAIL:         info@phpguardian.org
 *
 * COPYRIGHT:      2006-2011 Fabio Cicerchia
 * LICENSE:        GNU GPL 3+
 *                 This program is free software: you can redistribute it and/or
 *                 modify it under the terms of the GNU General Public License
 *                 as published by the Free Software Foundation, either version
 *                 3 of the License, or (at your option) any later version.
 *
 *                 This program is distributed in the hope that it will be
 *                 useful, but WITHOUT ANY WARRANTY; without even the implied
 *                 warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 *                 PURPOSE. See the GNU General Public License for more details.
 *
 *                 You should have received a copy of the GNU General Public
 *                 Licensealong with this program. If not, see
 *                 <http://www.gnu.org/licenses/>.
 *
 * $Id: encoder.c,v 1.10 2010-02-11 09:23:23 fabio Exp $
 **/

#ifndef _ENCODER_C
    // {{{ DEFINES
    #define _ENCODER_C
    // }}}

    // {{{ INCLUDES
    #include "../headers/cli.h"
    // }}}

    // {{{ METHODS
    // {{{ char *pg_code_crypt(char *data)
    /**
     * Encode the input data
     * @param char *data
     * @global char *PG_S_KEY_HASH
     * @return char *
     */
    char *pg_code_crypt(char *data) {
        int data_len = SLEN(data), key_len = SLEN(PG_S_KEY_HASH);

        // Increase file counter
        total_files++;

        // Check content size
        if (data_len == 0) {
            pg_message("WARNING: Skipped because the file content is empty.", false);
            return NULL;
        }

        // Check key size
        if (key_len == 0) {
            pg_message("ERROR: Skipped because the private key is empty.", false);
            return NULL;
        }

        // Print a message
        pg_message("Encoding %d bytes...", true, data_len);

        // Encrypt the data
        char *crdata = pg_cycle_encrypt(data, data_len, key_len);

        // Increase the total generated bytes
        total_generated_bytes += SLEN(crdata);

        // Print a message
        pg_message("Generated %d bytes.", true, SLEN(crdata));

        return crdata;
    }
    // }}}

    // char *pg_cycle_encrypt(char *string, int key_len, int data_len)
    /**
     * Encrypt a string
     * @param char *string
     * @param int key_len
     * @param int data_len
     * @global char *PG_S_KEY_HASH
     * @return char *
     */
    char *pg_cycle_encrypt(char *string, int key_len, int data_len) {
        int i;

        char *crdata = (char *)malloc(((2 * data_len) + 1) * sizeof(char));
        memset(crdata, 0, sizeof(crdata));

        // Encode the data
        for(i = 0; i < data_len; i++) {
            strcat(crdata, encode_char(string[i], PG_S_KEY_HASH[i % key_len]));
        }
        crdata[2 * data_len] = '\0';

        return crdata;
    }
    // }}}

    // {{{ char *encode_char(char character, char key)
    /**
     * Encode a single character
     * @param char character
     * @param char key
     * @return char *
     */
    char *encode_char(char character, char key) {
        return int2hex((unsigned int)X((int)character, (int)key));
    }
    // }}}

    // {{{ void pg_encode_file(int pos, bool is_dir)
    /**
     * Encode a file
     * @param int pos
     * @param bool is_dir
     * @global bool PG_S_USE_ASP_TAGS
     * @return void
     */
    void pg_encode_file(int pos, bool is_dir) {
        // Get the filename
        char *filename = get_filename(pos, is_dir);

        // Check if filename isn't empty
        if (is_equal(filename, "")) {
            free(filename);
            return;
        }

        // Get the element
        PGSS curr_element = get_element(pos, is_dir);

        char *inner_content = get_inner();
        char *header_content = get_header(curr_element, inner_content);
        char *footer_content = get_footer(curr_element);

        // Open it
        DIR *pdir = opendir(filename);

        // Print a message
        printf(_("Start encoding file `%s'."), filename);
        printf("\n");

        // Is a file?
        if (pdir == NULL) {
            // Get the content
            char *file_content = file_get_content(filename);
            // Convert the content
            char *converted_content = pg_convert(file_content, PG_S_USE_ASP_TAGS);
            free(file_content);

            // If the converted data is empty
            if (is_equal(converted_content, "")) {
                // Set the file as skipped
                // TODO: CHANGE: array_push
                skipped_files = (char **)realloc(skipped_files, (sizeof(skipped_files) + 1) * sizeof(char *));
                skipped_files[count_skipped] = filename;
                count_skipped++;

                // Print a message
                pg_message("ERROR: The converted data is empty.", false);
                goto freeing;
            }
            char *encoded_content = pg_code_crypt(converted_content);
            free(converted_content);
            if (!is_equal(encoded_content, "")) {
                rename_file(filename);
                char *encoded_filename = get_encoded_filename(filename);
                // Print a message
                pg_message("Saving %d bytes...", true, SLEN(encoded_content));

                // Save the file
                file_put_content(filename, encoded_content, header_content, footer_content);
                free(encoded_filename);
            } else {
                // Set the file as skipped
                // CHANGE: array_push
                skipped_files = (char **)realloc(skipped_files, (sizeof(skipped_files) + 1) * sizeof(char *));
                skipped_files[count_skipped] = filename;

                count_skipped++;

                // Print a message
                pg_message("ERROR: The encoded data is empty.", false);
            }
            free(encoded_content);
        } else {
            //TODO: walkdir(filename);
        }

    freeing:
        free(curr_element.PATH);
        free(curr_element.HEADER);
        free(curr_element.FOOTER);
        free(filename);
        free(inner_content);
        free(header_content);
        free(footer_content);
    }
    // }}}

    // {{{ static PGSS get_element(int pos, bool is_dir)
    /**
     * Get the element for the specific position
     * @param int pos
     * @param bool is_dir
     * @global PGSS PG_S_PATHS[]
     * @global char *PG_S_SINGLE_FILE
     * @global PGSS PG_S_FILES[]
     * @return char *
     */
    static PGSS get_element(int pos, bool is_dir) {
        if (is_dir)                               return PG_S_PATHS[pos];
        else if (!is_equal(PG_S_SINGLE_FILE, "")) return PG_S_PATHS[pos];
        else if (is_equal(PG_S_SINGLE_FILE, ""))  return PG_S_FILES[pos];
        else {
            PGSS tmp;
            return tmp;
        }
    }
    // }}}

    // {{{ static char *get_inner()
    /**
     * Get the inner content
     * @global int MAX_SIZE
     * @global bool PG_S_USE_PHP_EXTENSION
     * @global char *PHPG_EXTENSION_STRING
     * @global char *PG_S_EXTENSION_MODULE_PATH
     * @global char *PHPG_LIBRARY_STRING
     * @global char *PG_S_BASE_LIB_PATH
     * @return char *
     */
    static char *get_inner() {
        char *inner = (char *)malloc((MAX_SIZE) * sizeof(char));
        memset(inner, 0, sizeof(inner));
        if (PG_S_USE_PHP_EXTENSION) {
            (void)snprintf(inner, (size_t)(strlen(PHPG_EXTENSION_STRING) - 4 + strlen(PG_S_EXTENSION_MODULE_PATH) + strlen(PG_S_EXTENSION_MODULE_PATH)), PHPG_EXTENSION_STRING, PG_S_EXTENSION_MODULE_PATH, PG_S_EXTENSION_MODULE_PATH);
        } else {
            (void)snprintf(inner, (size_t)(strlen(PHPG_LIBRARY_STRING) - 2 + strlen(PG_S_BASE_LIB_PATH)), PHPG_LIBRARY_STRING, PG_S_BASE_LIB_PATH);
        }
        inner[SLEN(inner)] = '\0';

        return inner;
    }
    // }}}

    // {{{ static char *get_header(PGSS element, char *inner)
    /**
     * Get the header
     * @param PGSS element
     * @param char *inner
     * @global char *PG_S_HEADER
     * @return char *
     */
    static char *get_header(PGSS element, char *inner) {
        int len;
        char *header;
        if (element.HEADER != PG_S_HEADER) {
            len = SLEN(PG_S_HEADER) + SLEN(inner);

            header = (char *)malloc((8 + len) * sizeof(char));
            memset(header, 0, sizeof(header));
            (void)snprintf(header, (size_t)(7 + strlen(PG_S_HEADER) + strlen(inner)), "<?php\n\n%s%s", PG_S_HEADER, inner);
        } else {
            len = SLEN(element.HEADER) + SLEN(inner);

            header = (char *)malloc((8 + len) * sizeof(char));
            memset(header, 0, sizeof(header));
            (void)snprintf(header, (size_t)(7 + strlen(element.HEADER) + strlen(inner)), "<?php\n\n%s%s", element.HEADER, inner);
        }
        header[7 + len] = '\0';

        return header;
    }
    // }}}

    // {{{ static char *get_footer(PGSS element)
    /**
     * Get the footer
     * @param PGSS element
     * @global char *PG_S_FOOTER
     * @return char *
     */
    static char *get_footer(PGSS element) {
        int len;
        char *footer;

        if (element.FOOTER != PG_S_FOOTER) {
            len = SLEN(PG_S_FOOTER);

            footer = (char *)malloc((8 + len) * sizeof(char));
            memset(footer, 0, sizeof(footer));
            (void)snprintf(footer, (size_t)(7 + strlen(PG_S_FOOTER)), "');\n%s\n?>", PG_S_FOOTER);
        } else {
            len = SLEN(element.FOOTER);

            footer = (char *)malloc((8 + len) * sizeof(char));
            memset(footer, 0, sizeof(footer));
            (void)snprintf(footer, (size_t)(7 + strlen(element.FOOTER)), "');\n%s\n?>", element.FOOTER);
        }
        footer[7 + len] = '\0';

        return footer;
    }

    // {{{ static char *get_encoded_filename(char *filename)
    /**
     * Get the encoded filename
     * @param char *filename
     * @global bool PG_S_SAVE_ENCODED_AS_NEW
     * @return char *
     */
    static char *get_encoded_filename(char *filename) {
        int filename_len = SLEN(filename);
        char *encoded_filename;

        if (PG_S_SAVE_ENCODED_AS_NEW) {
            encoded_filename = (char *)malloc((9 + filename_len) * sizeof(char));
            (void)snprintf(encoded_filename, (size_t)(8 + filename_len), "%s.encoded", filename);
            encoded_filename[8 + filename_len] = '\0';
        } else {
            encoded_filename = (char *)malloc((1 + filename_len) * sizeof(char));
            strcpy(encoded_filename, filename);
            encoded_filename[filename_len] = '\0';
        }

        return encoded_filename;
    }
    // }}}

    // {{{ void pg_create_file_key()
    /**
     * Create a file private-key
     * @global char *PG_S_KEY_FILE
     * @global char *PG_S_KEY_HASH
     * @global const PHPG_HEADER_KEY
     * @global const PHPG_FOOTER_KEY
     * @return void
     */
    void pg_create_file_key() {
        if (is_equal(PG_S_KEY_FILE, "")) {
            strcpy(PG_S_KEY_FILE, "key.pgk");
        }

        pg_message("Saving key (%d bytes) into file `%s'.", true, SLEN(PG_S_KEY_HASH), PG_S_KEY_FILE);

        (void)remove(PG_S_KEY_FILE);
        //TODO: file_put_content(PG_S_KEY_FILE, PG_S_KEY_HASH, PHPG_HEADER_KEY, PHPG_FOOTER_KEY);
        file_put_content(PG_S_KEY_FILE, PG_S_KEY_HASH, "", "");
    }
    // }}}
    // }}}
#endif /* _ENCODER_C */
