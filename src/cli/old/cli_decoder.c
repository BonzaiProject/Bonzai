/**
 *        _            ____                     _ _             ____
 *  _ __ | |__  _ __  / ___|_   _  __ _ _ __ __| (_) __ _ _ __ |___ \
 * | '_ \| '_ \| '_ \| |  _| | | |/ _` | '__/ _` | |/ _` | '_ \  __) |
 * | |_) | | | | |_) | |_| | |_| | (_| | | | (_| | | (_| | | | |/ __/
 * | .__/|_| |_| .__/ \____|\__,_|\__,_|_|  \__,_|_|\__,_|_| |_|_____|
 * |_|         |_| phpGuardian CLI
 *
 *
 * PHPGUARDIAN2
 *
 * CODE NAME:      phoenix
 * ENGINE VERSION: 4.0
 * MODULE VERSION: 1.0
 *
 * URL:            http://www.phpguardian.org
 * E-MAIL:         info@phpguardian.org
 *
 * COPYRIGHT:      2006-2011 Fabio Cicerchia
 * LICENSE:        GNU GPL 3+
 *                 This program is free software: you can redistribute it and/or
 *                 modify it under the terms of the GNU General Public License
 *                 as published by the Free Software Foundation, either version
 *                 3 of the License, or (at your option) any later version.
 *
 *                 This program is distributed in the hope that it will be
 *                 useful, but WITHOUT ANY WARRANTY; without even the implied
 *                 warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
 *                 PURPOSE. See the GNU General Public License for more details.
 *
 *                 You should have received a copy of the GNU General Public
 *                 Licensealong with this program. If not, see
 *                 <http://www.gnu.org/licenses/>.
 *
 * $Id: decoder.c,v 1.5 2010-02-11 09:23:23 fabio Exp $
 **/

#ifndef _DECODER_C
    // {{{ DEFINES
    #define _DECODER_C
    // }}}

    // {{{ METHODS
    // {{{ char *pg_code_decrypt(char *data)
    /**
     * Decode the input data
     * @param char *data
     * @global char *PG_S_KEY_HASH
     * @return char *
     */
    char *pg_code_decrypt(char *data) {
        int data_len = SLEN(data), key_len = SLEN(PG_S_KEY_HASH);

        // Increase file counter
        total_files++;

        // Check content size
        if (data_len == 0) {
            pg_message("WARNING: Skipped because the file content is empty.", false);
            return NULL;
        }

        // Check key size
        if (key_len == 0) {
            pg_message("ERROR: Skipped because the private key is empty.", false);
            return NULL;
        }

        // Check if is a phpguardian file
        int start = strpos(data, "phpg_exec('", 0);
        int end = strpos(data, "')", start);
        if (start == -1 || end == -1) {
            pg_message("ERROR: Skipped because isn't a phpguardian file.", false);
            return "";
        }
        start += 11;

        // Get the encoded data
        char *tmpdata = (char *)malloc(((end - start) + 1) * sizeof(char));
        strncpy(tmpdata, data + start, end - start);
        tmpdata[end - start] = '\0';
        data_len = end - start;

        if (tmpdata[data_len] == '\0' && ((data_len % 2) != 0)) {
            data_len--;
        }
        tmpdata[data_len] = '\0';

        // Print a message
        pg_message("Decoding %d bytes...", true, data_len);

        // Decrypt the data
        char *crdata = pg_cycle_decrypt(tmpdata, key_len, data_len);
        free(tmpdata);

        // Increase the total generated bytes
        total_generated_bytes += SLEN(crdata);

        // Print a message
        pg_message("Restored %d bytes.", true, SLEN(crdata));

        return crdata;
    }
    // }}}

    // {{{ char *pg_cycle_decrypt(char *string, int key_len, int data_len)
    /**
     * Decrypt a string
     * @param char *string
     * @param int key_len
     * @param int data_len
     * @global char *PG_S_KEY_HASH
     * @return char *
     */
    char *pg_cycle_decrypt(char *string, int key_len, int data_len) {
        int i, j = 0;
        char *enc_data = (char *)malloc(sizeof(char));
        char enc_char[2];

        // Init the container string
        char *crdata = (char *)malloc(((data_len / 2) + 1) * sizeof(char));
        memset(crdata, 0, sizeof(crdata));

        // Decode it
        for(i = 0; i < data_len; i += 2) {
            strncpy(enc_char, string + i, 2);
            enc_char[2] = '\0';
            free(enc_data);
            enc_data = decode_char(enc_char, PG_S_KEY_HASH[j % key_len]);
            strcat(crdata, enc_data);
            j++;
        }
        free(enc_data);

        return crdata;
    }
    // }}}

    // {{{ static char *decode_char(char *characters, char key)
    /**
     * Decode a single character
     * @param char *characters
     * @param char key
     * @return char *
     */
    static char *decode_char(char *characters, char key) {
        char *enc_data = (char *)malloc(sizeof(char));
        (void)snprintf(enc_data, (size_t)1, "%c", (char)X(hex2int(characters), (int)key));
        enc_data[1] = '\0';
        return enc_data;
    }
    // }}}

    // {{{ void pg_decode_file(int pos, bool is_dir)
    /**
     * Decode a file
     * @param int pos
     * @param bool is_dir
     * @global PGSS PG_S_PATHS[]
     * @global char *PG_S_SINGLE_FILE
     * @global bool PG_S_SAVE_ORIGINAL_AS_BAK
     * @global bool PG_S_SAVE_DECODED_AS_NEW
     * @return void
     */
    void pg_decode_file(int pos, bool is_dir) {
        // Get the filename
        char *filename = get_filename(pos, is_dir);

        // Check if filename isn't empty
        if (is_equal(filename, "")) {
            return;
        }

        // Open it
        DIR *pdir = opendir(filename);

        // Print a message
        printf(_("Start decoding file `%s'."), filename);
        printf("\n");

        // Is a file?
        if (pdir == NULL) {
            // Get the content
            char *file_content = file_get_content(filename);
            // Increase the total originary bytes
            total_orig_bytes += SLEN(file_content);
            // Decode the content
            char *decoded_content = pg_code_decrypt(file_content);
            free(file_content);

            // If the decoded data isn't empty
            if (!is_equal(decoded_content, "")) {
                rename_file(filename);
                char *decoded_filename = get_decoded_filename(filename);

                // Print a message
                pg_message("Saving %d bytes...", true, SLEN(decoded_content));

                // Save the file
                file_put_content(decoded_filename, decoded_content, "", "");
                free(decoded_filename);
            } else {
                // Set the file as skipped
                // TODO: CHANGE: array_push
                skipped_files = (char **)realloc(skipped_files, (sizeof(skipped_files) + 1) * sizeof(char *));
                skipped_files[count_skipped] = filename;

                count_skipped++;

                // Print a message
                pg_message("ERROR: The decoded data is empty.", false);
            }
            free(decoded_content);
        } else {
            //TODO: walkdir(filename);
        }
        free(filename);
    }
    // }}}

    // {{{ static char *get_decoded_filename(char *filename)
    /**
     * Get the decoded filename
     * @param char *filename
     * @global bool PG_S_SAVE_DECODED_AS_NEW
     * @return char *
     */
    static char *get_decoded_filename(char *filename) {
        int file_len = SLEN(filename);
        char *decoded_filename;

        if (PG_S_SAVE_DECODED_AS_NEW) {
            decoded_filename = (char *)malloc((9 + file_len) * sizeof(char)); // TODO: Why 9?
            (void)snprintf(decoded_filename, (size_t)(8 + file_len), "%s.decoded", filename);
            decoded_filename[9 + file_len] = '\0';
        } else {
            decoded_filename = (char *)malloc((1 + file_len) * sizeof(char));
            strcpy(decoded_filename, filename);
            decoded_filename[1 + file_len] = '\0';
        }

        return decoded_filename;
    }
    // }}}
    // }}}
#endif /* _DECODER_C */
